"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NeConstView = exports.NeConst = exports.EqConstView = exports.EqConst = exports.GeConstView = exports.GeConst = exports.GtConstView = exports.GtConst = exports.LeConstView = exports.LeConst = exports.LtConstView = exports.LtConst = exports.ShiftRightConstView = exports.ShiftRightConst = exports.ShiftLeftConstView = exports.ShiftLeftConst = exports.PowerConstView = exports.PowerConst = exports.ModuloConstView = exports.ModuloConst = exports.DivisionConstView = exports.DivisionConst = exports.MultiplicationConstView = exports.MultiplicationConst = exports.SubtractionConstView = exports.SubtractionConst = exports.AdditionConstView = exports.AdditionConst = exports.EqCompareConst = exports.CompareConst = exports.BaseCompareConst = exports.ShiftConst = exports.ArithConst = exports.OpConst = exports.NeView = exports.Ne = exports.EqView = exports.Eq = exports.GeView = exports.Ge = exports.GtView = exports.Gt = exports.LeView = exports.Le = exports.LtView = exports.Lt = exports.ShiftRightView = exports.ShiftRight = exports.ShiftLeftView = exports.ShiftLeft = exports.PowerView = exports.Power = exports.ModuloView = exports.Modulo = exports.DivisionView = exports.Division = exports.MultiplicationView = exports.Multiplication = exports.SubtractionView = exports.Subtraction = exports.AdditionView = exports.Addition = exports.UnaryPlusView = exports.UnaryPlus = exports.NegationView = exports.Negation = exports.EqCompare = exports.Compare = exports.BaseCompare = exports.Shift = exports.Arith21 = exports.Arith11 = exports.Arith = void 0;

var joint = _interopRequireDefault(require("jointjs"));

var _base = require("./base.js");

var help = _interopRequireDefault(require("../help.js"));

var _vl = require("3vl");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isSafeInteger(v) {
  return v <= Number.MAX_SAFE_INTEGER && v >= -Number.MAX_SAFE_INTEGER;
} // base class for arithmetic operations displayed with a circle


const Arith = _base.Gate.define('Arith', {
  size: {
    width: 40,
    height: 40
  },
  attrs: {
    body: {
      refR: 0.5,
      refCx: 0.5,
      refCy: 0.5
    },
    oper: {
      refX: .5,
      refY: .5,
      textAnchor: 'middle',
      textVerticalAnchor: 'middle',
      fontSize: '12pt'
    }
  },
  ports: {
    groups: {
      'in': {
        position: {
          name: 'left',
          args: {
            dx: 10
          }
        },
        attrs: {
          wire: {
            x2: -35
          },
          port: {
            refX: -35
          }
        },
        z: -1
      },
      'out': {
        position: {
          name: 'right',
          args: {
            dx: -10
          }
        },
        attrs: {
          wire: {
            x2: 35
          },
          port: {
            refX: 35
          }
        },
        z: -1
      }
    }
  }
}, {
  markup: _base.Gate.prototype.markup.concat([{
    tagName: 'circle',
    className: 'body',
    selector: 'body'
  }, {
    tagName: 'text',
    className: 'oper',
    selector: 'oper'
  }]),
  _gateParams: _base.Gate.prototype._gateParams.concat(['bits', 'signed']),
  _unsupportedPropChanges: _base.Gate.prototype._unsupportedPropChanges.concat(['signed'])
}); // Unary arithmetic operations


exports.Arith = Arith;
const Arith11 = Arith.define('Arith11', {
  /* default properties */
  bits: {
    in: 1,
    out: 1
  },
  signed: false
}, {
  initialize() {
    const bits = this.get('bits');
    this.get('ports').items = [{
      id: 'in',
      group: 'in',
      dir: 'in',
      bits: bits.in
    }, {
      id: 'out',
      group: 'out',
      dir: 'out',
      bits: bits.out
    }];
    Arith.prototype.initialize.apply(this, arguments);
    this.on('change:bits', (_, bits) => {
      this._setPortsBits(bits);
    });
  },

  operation(data) {
    const bits = this.get('bits');
    if (!data.in.isFullyDefined) return {
      out: _vl.Vector3vl.xes(bits.out)
    };
    return {
      out: _vl.Vector3vl.fromNumber(this.arithop(data.in.toBigInt(this.get('signed'))), bits.out)
    };
  },

  _operationHelpers: Arith.prototype._operationHelpers.concat(['arithop'])
}); // Binary arithmetic operations

exports.Arith11 = Arith11;
const Arith21 = Arith.define('Arith21', {
  /* default properties */
  bits: {
    in1: 1,
    in2: 1,
    out: 1
  },
  signed: {
    in1: false,
    in2: false
  }
}, {
  initialize() {
    const bits = this.get('bits');
    this.get('ports').items = [{
      id: 'in1',
      group: 'in',
      dir: 'in',
      bits: bits.in1
    }, {
      id: 'in2',
      group: 'in',
      dir: 'in',
      bits: bits.in2
    }, {
      id: 'out',
      group: 'out',
      dir: 'out',
      bits: bits.out
    }];
    Arith.prototype.initialize.apply(this, arguments);
    this.on('change:bits', (_, bits) => {
      this._setPortsBits(bits);
    });
  },

  operation(data) {
    const bits = this.get('bits');
    const sgn = this.get('signed');
    if (!data.in1.isFullyDefined || !data.in2.isFullyDefined) return {
      out: _vl.Vector3vl.xes(bits.out)
    };
    return {
      out: _vl.Vector3vl.fromNumber(this.arithop(data.in1.toBigInt(sgn.in1 && sgn.in2), data.in2.toBigInt(sgn.in1 && sgn.in2)), bits.out)
    };
  },

  _operationHelpers: Arith.prototype._operationHelpers.concat(['arithop'])
});
exports.Arith21 = Arith21;

function shiftHelp(in1, am, bits_in, bits_out, sgn_in, sgn_out, fillx) {
  const signbit = in1.get(in1.bits - 1);

  const ext = _vl.Vector3vl.make(Math.max(0, bits_out - bits_in), fillx ? 0 : sgn_in ? signbit : -1);

  const my_in = in1.concat(ext);
  const out = am < 0 ? _vl.Vector3vl.make(-am, fillx ? 0 : -1).concat(my_in) : my_in.slice(am).concat(_vl.Vector3vl.make(am, fillx ? 0 : sgn_out ? my_in.get(my_in.bits - 1) : -1));
  return out.slice(0, bits_out);
} // Bit shift operations


const Shift = Arith.define('Shift', {
  /* default properties */
  bits: {
    in1: 1,
    in2: 1,
    out: 1
  },
  signed: {
    in1: false,
    in2: false,
    out: false
  },
  fillx: false
}, {
  initialize() {
    const bits = this.get('bits');
    this.get('ports').items = [{
      id: 'in1',
      group: 'in',
      dir: 'in',
      bits: bits.in1
    }, {
      id: 'in2',
      group: 'in',
      dir: 'in',
      bits: bits.in2
    }, {
      id: 'out',
      group: 'out',
      dir: 'out',
      bits: bits.out
    }];
    Arith.prototype.initialize.apply(this, arguments);
    this.on('change:bits', (_, bits) => {
      this._setPortsBits(bits);
    });
  },

  operation(data) {
    const bits = this.get('bits');
    const sgn = this.get('signed');
    const fillx = this.get('fillx');
    if (!data.in2.isFullyDefined) return {
      out: _vl.Vector3vl.xes(bits.out)
    };
    const am = data.in2.toNumber(sgn.in2) * this.shiftdir;
    return {
      out: shiftHelp(data.in1, am, bits.in1, bits.out, sgn.in1, sgn.out, fillx)
    };
  },

  _gateParams: Arith.prototype._gateParams.concat(['fillx']),
  _unsupportedPropChanges: Arith.prototype._unsupportedPropChanges.concat(['fillx']),
  _operationHelpers: Arith.prototype._operationHelpers.concat(['shiftdir'])
}); // Comparison operations

exports.Shift = Shift;
const BaseCompare = Arith.define('BaseCompare', {
  /* default properties */
  bits: {
    in1: 1,
    in2: 1
  },
  signed: {
    in1: false,
    in2: false
  }
}, {
  initialize() {
    const bits = this.get('bits');
    this.get('ports').items = [{
      id: 'in1',
      group: 'in',
      dir: 'in',
      bits: bits.in1
    }, {
      id: 'in2',
      group: 'in',
      dir: 'in',
      bits: bits.in2
    }, {
      id: 'out',
      group: 'out',
      dir: 'out',
      bits: 1
    }];
    Arith.prototype.initialize.apply(this, arguments);
    this.on('change:bits', (_, bits) => {
      this._setPortsBits(bits);
    });
  }

}); // Arithmetic comparison operations

exports.BaseCompare = BaseCompare;
const Compare = BaseCompare.define('Compare', {}, {
  operation(data) {
    const bits = this.get('bits');
    const sgn = this.get('signed');
    if (!data.in1.isFullyDefined || !data.in2.isFullyDefined) return {
      out: _vl.Vector3vl.xes(1)
    };
    return {
      out: _vl.Vector3vl.fromBool(this.arithcomp(data.in1.toBigInt(sgn.in1 && sgn.in2), data.in2.toBigInt(sgn.in1 && sgn.in2)))
    };
  },

  _operationHelpers: BaseCompare.prototype._operationHelpers.concat(['arithcomp'])
}); // Equality operations

exports.Compare = Compare;
const EqCompare = BaseCompare.define('EqCompare', {}, {
  operation(data) {
    const bits = this.get('bits');
    const sgn = this.get('signed');
    const in1 = bits.in1 >= bits.in2 ? data.in1 : data.in1.concat(_vl.Vector3vl.make(bits.in2 - bits.in1, sgn.in1 && sgn.in2 ? data.in1.msb : -1));
    const in2 = bits.in2 >= bits.in1 ? data.in2 : data.in2.concat(_vl.Vector3vl.make(bits.in1 - bits.in2, sgn.in1 && sgn.in2 ? data.in2.msb : -1));
    return {
      out: this.bincomp(in1, in2)
    };
  },

  _operationHelpers: BaseCompare.prototype._operationHelpers.concat(['bincomp'])
}); // Negation

exports.EqCompare = EqCompare;
const Negation = Arith11.define('Negation', {
  attrs: {
    oper: {
      text: '-'
    }
  }
}, {
  arithop: i => -i
});
exports.Negation = Negation;
const NegationView = _base.GateView; // Unary plus

exports.NegationView = NegationView;
const UnaryPlus = Arith11.define('UnaryPlus', {
  attrs: {
    oper: {
      text: '+'
    }
  }
}, {
  arithop: i => i
});
exports.UnaryPlus = UnaryPlus;
const UnaryPlusView = _base.GateView; // Addition

exports.UnaryPlusView = UnaryPlusView;
const Addition = Arith21.define('Addition', {
  attrs: {
    oper: {
      text: '+'
    }
  }
}, {
  arithop: (i, j) => i + j
});
exports.Addition = Addition;
const AdditionView = _base.GateView; // Subtraction

exports.AdditionView = AdditionView;
const Subtraction = Arith21.define('Subtraction', {
  attrs: {
    oper: {
      text: '-'
    }
  }
}, {
  arithop: (i, j) => i - j
});
exports.Subtraction = Subtraction;
const SubtractionView = _base.GateView; // Multiplication

exports.SubtractionView = SubtractionView;
const Multiplication = Arith21.define('Multiplication', {
  attrs: {
    oper: {
      text: '×'
    }
  }
}, {
  arithop: (i, j) => i * j
});
exports.Multiplication = Multiplication;
const MultiplicationView = _base.GateView; // Division

exports.MultiplicationView = MultiplicationView;
const Division = Arith21.define('Division', {
  attrs: {
    oper: {
      text: '÷'
    }
  }
}, {
  arithop: (i, j) => j == 0n ? i : i / j // as in IEEE Verilog

});
exports.Division = Division;
const DivisionView = _base.GateView; // Modulo

exports.DivisionView = DivisionView;
const Modulo = Arith21.define('Modulo', {
  attrs: {
    oper: {
      text: '%'
    }
  }
}, {
  arithop: (i, j) => j == 0n ? i : i % j // as in IEEE Verilog

});
exports.Modulo = Modulo;
const ModuloView = _base.GateView; // Power

exports.ModuloView = ModuloView;
const Power = Arith21.define('Power', {
  attrs: {
    oper: {
      text: '^'
    }
  }
}, {
  arithop: (i, j) => j >= 0n ? i ** j : i == 1n ? 1n : i == -1n ? j % 2n ? -1n : 1n : 0n
});
exports.Power = Power;
const PowerView = _base.GateView; // Shift left operator

exports.PowerView = PowerView;
const ShiftLeft = Shift.define('ShiftLeft', {
  attrs: {
    oper: {
      text: '≪'
    }
  }
}, {
  shiftdir: -1
});
exports.ShiftLeft = ShiftLeft;
const ShiftLeftView = _base.GateView; // Shift right operator

exports.ShiftLeftView = ShiftLeftView;
const ShiftRight = Shift.define('ShiftRight', {
  attrs: {
    oper: {
      text: '≫'
    }
  }
}, {
  shiftdir: 1
});
exports.ShiftRight = ShiftRight;
const ShiftRightView = _base.GateView; // Less than operator

exports.ShiftRightView = ShiftRightView;
const Lt = Compare.define('Lt', {
  attrs: {
    oper: {
      text: '<'
    }
  }
}, {
  arithcomp: (i, j) => i < j
});
exports.Lt = Lt;
const LtView = _base.GateView; // Less or equal operator

exports.LtView = LtView;
const Le = Compare.define('Le', {
  attrs: {
    oper: {
      text: '≤'
    }
  }
}, {
  arithcomp: (i, j) => i <= j
});
exports.Le = Le;
const LeView = _base.GateView; // Greater than operator

exports.LeView = LeView;
const Gt = Compare.define('Gt', {
  attrs: {
    oper: {
      text: '>'
    }
  }
}, {
  arithcomp: (i, j) => i > j
});
exports.Gt = Gt;
const GtView = _base.GateView; // Less than operator

exports.GtView = GtView;
const Ge = Compare.define('Ge', {
  attrs: {
    oper: {
      text: '≥'
    }
  }
}, {
  arithcomp: (i, j) => i >= j
});
exports.Ge = Ge;
const GeView = _base.GateView; // Equality operator

exports.GeView = GeView;
const Eq = EqCompare.define('Eq', {
  attrs: {
    oper: {
      text: '='
    }
  }
}, {
  bincomp: (i, j) => i.xnor(j).reduceAnd()
});
exports.Eq = Eq;
const EqView = _base.GateView; // Nonequality operator

exports.EqView = EqView;
const Ne = EqCompare.define('Ne', {
  attrs: {
    oper: {
      text: '≠'
    }
  }
}, {
  bincomp: (i, j) => i.xor(j).reduceOr()
});
exports.Ne = Ne;
const NeView = _base.GateView;
exports.NeView = NeView;
const OpConst = Arith.define('OpConst', {
  leftOp: false,
  constant: 0
}, {
  initialize() {
    Arith.prototype.initialize.apply(this, arguments);
    let constant = this.get('constant');

    if (typeof constant === 'string' || constant instanceof String) {
      constant = BigInt(constant);
      if (isSafeInteger(constant)) constant = Number(constant);
      this.set('constant', constant);
    }

    const genLabel = () => {
      const constantSize = String(this.get('constant')).length;
      const diameter = 30 + constantSize * 10;
      this.prop("size", {
        width: diameter,
        height: diameter
      });
      this.attr("oper/text", this.get('leftOp') ? this.get('constant') + this.operSymbol : this.operSymbol + this.get('constant'));
    };

    genLabel();
    this.on('change:bits', (_, bits) => {
      this._setPortsBits(bits);
    });
    this.on('change:constant', () => genLabel());
    this.on('change:leftOp', () => genLabel());
  },

  getGateParams() {
    const params = Arith.prototype.getGateParams.apply(this, arguments); // `constant` may be a bigint and we need to encode it manually

    if (typeof params.constant === 'bigint') {
      if (isSafeInteger(params.constant)) {
        params.constant = Number(params.constant);
      } else {
        params.constant = String(params.constant);
      }
    }

    return params;
  },

  _gateParams: Arith.prototype._gateParams.concat(['leftOp', 'constant'])
}); // Arithmetic operations fused with constants

exports.OpConst = OpConst;
const ArithConst = OpConst.define('ArithConst', {
  /* default properties */
  bits: {
    in: 1,
    out: 1
  },
  signed: false
}, {
  initialize() {
    const bits = this.get('bits');
    this.get('ports').items = [{
      id: 'in',
      group: 'in',
      dir: 'in',
      bits: bits.in
    }, {
      id: 'out',
      group: 'out',
      dir: 'out',
      bits: bits.out
    }];
    OpConst.prototype.initialize.apply(this, arguments);
  },

  operation(data) {
    const bits = this.get('bits');
    const sgn = this.get('signed');
    const constant = this.get('constant');
    if (!data.in.isFullyDefined) return {
      out: _vl.Vector3vl.xes(bits.out)
    };
    if (this.get('leftOp')) return {
      out: _vl.Vector3vl.fromNumber(this.arithop(BigInt(constant), data.in.toBigInt(sgn.in)), bits.out)
    };else return {
      out: _vl.Vector3vl.fromNumber(this.arithop(data.in.toBigInt(sgn.in), BigInt(constant)), bits.out)
    };
  },

  _operationHelpers: OpConst.prototype._operationHelpers.concat(['arithop'])
}); // Bit shift operations fused with constants

exports.ArithConst = ArithConst;
const ShiftConst = OpConst.define('ShiftConst', {
  /* default properties */
  bits: {
    in: 1,
    out: 1
  },
  signed: {
    in: false,
    out: false
  },
  fillx: false
}, {
  initialize() {
    const bits = this.get('bits');
    this.get('ports').items = [{
      id: 'in',
      group: 'in',
      dir: 'in',
      bits: bits.in
    }, {
      id: 'out',
      group: 'out',
      dir: 'out',
      bits: bits.out
    }];
    OpConst.prototype.initialize.apply(this, arguments);
  },

  operation(data) {
    const bits = this.get('bits');
    const sgn = this.get('signed');
    const fillx = this.get('fillx');
    const constant = this.get('constant');

    if (this.get('leftOp')) {
      if (!data.in.isFullyDefined) return {
        out: _vl.Vector3vl.xes(bits.out)
      };
      const am = data.in.toNumber(sgn.in);

      const sig = _vl.Vector3vl.fromNumber(constant);

      return {
        out: shiftHelp(sig, am * this.shiftdir, sig.bits, bits.out, constant < 0, sgn.out, fillx)
      };
    } else {
      console.assert(isSafeInteger(constant));
      return {
        out: shiftHelp(data.in, Number(constant) * this.shiftdir, bits.in, bits.out, sgn.in, sgn.out, fillx)
      };
    }
  },

  _gateParams: OpConst.prototype._gateParams.concat(['fillx']),
  _operationHelpers: OpConst.prototype._operationHelpers.concat(['shiftdir'])
}); // Comparison operations fused with constants

exports.ShiftConst = ShiftConst;
const BaseCompareConst = OpConst.define('BaseCompareConst', {
  /* default properties */
  bits: {
    in: 1
  },
  signed: false
}, {
  initialize() {
    const bits = this.get('bits');
    this.get('ports').items = [{
      id: 'in',
      group: 'in',
      dir: 'in',
      bits: bits.in
    }, {
      id: 'out',
      group: 'out',
      dir: 'out',
      bits: 1
    }];
    OpConst.prototype.initialize.apply(this, arguments);
  }

}); // Arithmetic comparisons fused with constants

exports.BaseCompareConst = BaseCompareConst;
const CompareConst = BaseCompareConst.define('CompareConst', {}, {
  operation(data) {
    const bits = this.get('bits');
    const sgn = this.get('signed');
    const constant = this.get('constant');
    if (!data.in.isFullyDefined) return {
      out: _vl.Vector3vl.x
    };
    if (this.get('leftOp')) return {
      out: _vl.Vector3vl.fromBool(this.arithcomp(BigInt(constant), data.in.toBigInt(sgn.in)))
    };else return {
      out: _vl.Vector3vl.fromBool(this.arithcomp(data.in.toBigInt(sgn.in), BigInt(constant)))
    };
  },

  _operationHelpers: BaseCompareConst.prototype._operationHelpers.concat(['arithcomp'])
}); // Equality operations fused with constants

exports.CompareConst = CompareConst;
const EqCompareConst = BaseCompareConst.define('EqCompareConst', {}, {
  operation(data) {
    const bits = this.get('bits');
    const sgn = this.get('signed');
    const constant = this.get('constant');
    if (this.get('leftOp')) return {
      out: this.bincomp(_vl.Vector3vl.fromNumber(constant, bits.in), data.in)
    };else return {
      out: this.bincomp(data.in, _vl.Vector3vl.fromNumber(constant, bits.in))
    };
  },

  _operationHelpers: BaseCompareConst.prototype._operationHelpers.concat(['bincomp'])
}); // Addition with constant

exports.EqCompareConst = EqCompareConst;
const AdditionConst = ArithConst.define('AdditionConst', {}, {
  operSymbol: '+',
  arithop: (i, j) => i + j
});
exports.AdditionConst = AdditionConst;
const AdditionConstView = _base.GateView; // Subtraction with constant

exports.AdditionConstView = AdditionConstView;
const SubtractionConst = ArithConst.define('SubtractionConst', {}, {
  operSymbol: '-',
  arithop: (i, j) => i - j
});
exports.SubtractionConst = SubtractionConst;
const SubtractionConstView = _base.GateView; // Multiplication with constant

exports.SubtractionConstView = SubtractionConstView;
const MultiplicationConst = ArithConst.define('MultiplicationConst', {}, {
  operSymbol: '×',
  arithop: (i, j) => i * j
});
exports.MultiplicationConst = MultiplicationConst;
const MultiplicationConstView = _base.GateView; // Division with constant

exports.MultiplicationConstView = MultiplicationConstView;
const DivisionConst = ArithConst.define('DivisionConst', {}, {
  operSymbol: '÷',
  arithop: (i, j) => j == 0n ? i : i / j // as in IEEE Verilog

});
exports.DivisionConst = DivisionConst;
const DivisionConstView = _base.GateView; // Modulo with constant

exports.DivisionConstView = DivisionConstView;
const ModuloConst = ArithConst.define('ModuloConst', {}, {
  operSymbol: '%',
  arithop: (i, j) => j == 0n ? i : i % j // as in IEEE Verilog

});
exports.ModuloConst = ModuloConst;
const ModuloConstView = _base.GateView; // Power with constant

exports.ModuloConstView = ModuloConstView;
const PowerConst = ArithConst.define('PowerConst', {}, {
  operSymbol: '^',
  arithop: (i, j) => j >= 0n ? i ** j : i == 1n ? 1n : i == -1n ? j % 2n ? -1n : 1n : 0n
});
exports.PowerConst = PowerConst;
const PowerConstView = _base.GateView; // Shift left operator

exports.PowerConstView = PowerConstView;
const ShiftLeftConst = ShiftConst.define('ShiftLeftConst', {}, {
  operSymbol: '≪',
  shiftdir: -1
});
exports.ShiftLeftConst = ShiftLeftConst;
const ShiftLeftConstView = _base.GateView; // Shift right operator

exports.ShiftLeftConstView = ShiftLeftConstView;
const ShiftRightConst = ShiftConst.define('ShiftRightConst', {}, {
  operSymbol: '≫',
  shiftdir: 1
});
exports.ShiftRightConst = ShiftRightConst;
const ShiftRightConstView = _base.GateView; // Less than operator

exports.ShiftRightConstView = ShiftRightConstView;
const LtConst = CompareConst.define('LtConst', {}, {
  operSymbol: '<',
  arithcomp: (i, j) => i < j
});
exports.LtConst = LtConst;
const LtConstView = _base.GateView; // Less than operator

exports.LtConstView = LtConstView;
const LeConst = CompareConst.define('LeConst', {}, {
  operSymbol: '≤',
  arithcomp: (i, j) => i <= j
});
exports.LeConst = LeConst;
const LeConstView = _base.GateView; // Less than operator

exports.LeConstView = LeConstView;
const GtConst = CompareConst.define('GtConst', {}, {
  operSymbol: '>',
  arithcomp: (i, j) => i > j
});
exports.GtConst = GtConst;
const GtConstView = _base.GateView; // Less than operator

exports.GtConstView = GtConstView;
const GeConst = CompareConst.define('GeConst', {}, {
  operSymbol: '≥',
  arithcomp: (i, j) => i >= j
});
exports.GeConst = GeConst;
const GeConstView = _base.GateView; // Equality operator

exports.GeConstView = GeConstView;
const EqConst = EqCompareConst.define('EqConst', {}, {
  operSymbol: '=',
  bincomp: (i, j) => i.xnor(j).reduceAnd()
});
exports.EqConst = EqConst;
const EqConstView = _base.GateView; // Nonequality operator

exports.EqConstView = EqConstView;
const NeConst = EqCompareConst.define('NeConst', {}, {
  operSymbol: '≠',
  bincomp: (i, j) => i.xor(j).reduceOr()
});
exports.NeConst = NeConst;
const NeConstView = _base.GateView;
exports.NeConstView = NeConstView;