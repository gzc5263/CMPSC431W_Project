"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "HeadlessCircuit", {
  enumerable: true,
  get: function () {
    return _circuit.HeadlessCircuit;
  }
});
Object.defineProperty(exports, "getCellType", {
  enumerable: true,
  get: function () {
    return _circuit.getCellType;
  }
});
Object.defineProperty(exports, "MonitorView", {
  enumerable: true,
  get: function () {
    return _monitor.MonitorView;
  }
});
Object.defineProperty(exports, "Monitor", {
  enumerable: true,
  get: function () {
    return _monitor.Monitor;
  }
});
Object.defineProperty(exports, "IOPanelView", {
  enumerable: true,
  get: function () {
    return _iopanel.IOPanelView;
  }
});
exports.transform = exports.tools = exports.engines = exports.cells = exports.Circuit = exports.paperOptions = void 0;

require("babel-polyfill");

var _dagre = _interopRequireDefault(require("dagre"));

var _graphlib = _interopRequireDefault(require("graphlib"));

var joint = _interopRequireDefault(require("jointjs"));

var _lodash = _interopRequireDefault(require("lodash"));

var _jquery = _interopRequireDefault(require("jquery"));

var _backbone = _interopRequireDefault(require("backbone"));

var _vl = require("3vl");

require("jquery-ui/ui/widgets/dialog.js");

require("jquery-ui/themes/base/all.css");

var cells = _interopRequireDefault(require("./cells.js"));

exports.cells = cells;

var engines = _interopRequireDefault(require("./engines.js"));

exports.engines = engines;

var tools = _interopRequireDefault(require("./tools.js"));

exports.tools = tools;

var transform = _interopRequireDefault(require("./transform.js"));

exports.transform = transform;

var _circuit = require("./circuit.js");

var _browsersynch = require("./engines/browsersynch.js");

var _monitor = require("./monitor.js");

var _iopanel = require("./iopanel.js");

var _elkjs = require("./elkjs.js");

require("./style.css.js");

var _resizeObserverPolyfill = _interopRequireDefault(require("resize-observer-polyfill"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// polyfill ResizeObserver for e.g. Firefox ESR 68.8
// this line and the node-module might be removed as soon as ResizeObserver is widely supported
// see https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver#Browser_compatibility
const paperOptions = {
  async: true,
  sorting: joint.dia.Paper.sorting.APPROX,
  //needed for async paper, see https://github.com/clientIO/joint/issues/1320
  width: 100,
  height: 100,
  gridSize: 5,
  magnetThreshold: 'onleave',
  snapLinks: true,
  linkPinning: false,
  markAvailable: true,
  defaultLink: new cells.Wire(),
  defaultConnectionPoint: {
    name: 'anchor'
  },
  defaultRouter: {
    name: 'metro',
    args: {
      startDirections: ['right'],
      endDirections: ['left'],
      maximumLoops: 200,
      step: 2.5
    }
  },
  defaultConnector: {
    name: 'rounded',
    args: {
      radius: 10
    }
  },
  cellViewNamespace: cells,

  validateConnection(vs, ms, vt, mt, e, vl) {
    if (e === 'target') {
      if (!mt) return false;
      const pt = vt.model.getPort(vt.findAttribute('port', mt));
      if (typeof pt !== 'object' || pt.dir !== 'in' || pt.bits !== vl.model.get('bits')) return false;
      const link = this.model.getConnectedLinks(vt.model).find(l => l.id !== vl.model.id && l.get('target').id === vt.model.id && l.get('target').port === vt.findAttribute('port', mt));
      return !link;
    } else if (e === 'source') {
      if (!ms) return false;
      const ps = vs.model.getPort(vs.findAttribute('port', ms));
      if (typeof ps !== 'object' || ps.dir !== 'out' || ps.bits !== vl.model.get('bits')) return false;
      return true;
    }
  }

};
exports.paperOptions = paperOptions;

class Circuit extends _circuit.HeadlessCircuit {
  constructor(data, {
    windowCallback = Circuit.prototype._defaultWindowCallback,
    layoutEngine = "elkjs",
    ...options
  } = {}) {
    if (!options.engine) options.engine = _browsersynch.BrowserSynchEngine;
    super(data, options);
    this._layoutEngine = layoutEngine;
    this._windowCallback = windowCallback;
    this.listenTo(this._engine, 'changeRunning', () => {
      this.trigger('changeRunning');
    });
  }

  _defaultWindowCallback(type, div, closingCallback) {
    const maxWidth = () => (0, _jquery.default)(window).width() * 0.9;

    const maxHeight = () => (0, _jquery.default)(window).height() * 0.9;

    function fixSize() {
      if (div.width() > maxWidth()) div.dialog("option", "width", maxWidth());
      if (div.height() > maxHeight()) div.dialog("option", "height", maxHeight());
    }

    const observer = new _resizeObserverPolyfill.default(fixSize);
    observer.observe(div.get(0));

    const shutdownCallback = () => {
      div.dialog('close');
    };

    this.listenToOnce(this, 'shutdown', shutdownCallback);
    const dialog = div.dialog({
      width: 'auto',
      height: 'auto',
      maxWidth: (0, _jquery.default)(window).width() * 0.9,
      maxHeight: (0, _jquery.default)(window).height() * 0.9,
      resizable: type !== "Memory",
      close: () => {
        this.stopListening(this, 'shutdown', shutdownCallback);
        closingCallback();
        observer.disconnect();
      }
    });
  }

  displayOn(elem) {
    return this._makePaper(elem, this._graph);
  }

  _makePaper(elem, graph) {
    this._engine.observeGraph(graph);

    const opts = _lodash.default.merge({
      el: elem,
      model: graph
    }, paperOptions);

    const paper = new joint.dia.Paper(opts);
    paper.$el.addClass('djs');
    paper.freeze(); // required for the paper to visualize the graph (jointjs bug?)

    graph.resetCells(graph.getCells()); // lazy graph layout

    if (!graph.get('laid_out')) {
      if (this._layoutEngine == "dagre") {
        joint.layout.DirectedGraph.layout(graph, {
          nodeSep: 20,
          edgeSep: 0,
          rankSep: 110,
          rankDir: "LR",
          setPosition: (element, position) => {
            element.setLayoutPosition({
              x: position.x - position.width / 2,
              y: position.y - position.height / 2,
              width: position.width,
              height: position.height
            });
          },
          exportElement: element => {
            return element.getLayoutSize();
          },
          dagre: _dagre.default,
          graphlib: _graphlib.default
        });
      } else if (this._layoutEngine == "elkjs") {
        (0, _elkjs.elk_layout)(graph);
      }

      graph.set('laid_out', true);
    }

    paper.listenTo(this, 'display:add', () => {
      // a very inefficient way to refresh numbase dropdowns
      // TODO: a better method
      paper.freeze();
      graph.resetCells(graph.getCells());
      paper.unfreeze();
    });
    this.listenTo(paper, 'render:done', () => {
      paper.fitToContent({
        padding: 30,
        allowNewOrigin: 'any'
      });
    });
    paper.unfreeze(); // subcircuit display

    this.listenTo(paper, 'open:subcircuit', model => {
      const div = (0, _jquery.default)('<div>', {
        title: model.get('celltype') + ' ' + model.get('label')
      }).appendTo('html > body');
      const pdiv = (0, _jquery.default)('<div>').appendTo(div);
      const graph = model.get('graph');

      const paper = this._makePaper(pdiv, graph);

      paper.once('render:done', () => {
        this._windowCallback('Subcircuit', div, () => {
          this._engine.unobserveGraph(graph);

          paper.remove();
          div.remove();
        });
      });
    });
    this.listenTo(paper, 'open:memorycontent', (div, closeCallback) => {
      this._windowCallback('Memory', div, closeCallback);
    });
    this.listenTo(paper, 'open:fsm', (div, closeCallback) => {
      this._windowCallback('FSM', div, closeCallback);
    });

    paper.fixed = function (fixed) {
      this.setInteractivity(!fixed);
      this.$el.toggleClass('fixed', fixed);
    };

    this.trigger('new:paper', paper);
    return paper;
  }

}

exports.Circuit = Circuit;
;